stop :- STOP
skip :- SKIP
eq :- :=
chanin :- ?
chanout :- !
copen :- {
cclose :- }
if :- IF
seqk :- SEQ
park :- PAR
int :- INT
chan :- CHAN
sqopen :- [
sqclose :- ]
popen :- (
pclose :- )
declend :- : 
eqq :- =
proc :- PROC
neg :-  -
not :- NOT
plus :- +
minus :- -
mul :- *
fs :- /
bs :- \
eqc :- =
lt :- <
le:- <=
gt :- >
ge :- >=
neq :- <>
and :- &
or :- |

dyadic.operator :- 

process :- stop | skip | action | construction | instance | specification process

action :- assignment | input | output

assignment :- variable eq expr

input :- channel chanin variable

output :- channel chanout expr

construction :- seq | cond | loop | par | alt

seq :- seqk copen { process } cclose

cond :- if { choice }

choice :- bool copen process close

bool :- expr

loop :- while bool copen process cclose

par :- park copen { process } cclose

alt :- guard copen process cclose

guard :- input | bool & input

type :- primitive.type | sqopen literal sqclose primitive.type

primitive.type = int | chan

literal :- integer

element :- name | name sqopen expr sqclose

variable :- element 

channel :- element

operand = element | literal | popen expr pclose

expr :- monadic.operator operand | operand dyadic.operator operand | operand 

specification :- decleration | definition 

decleration :- type name declend | int name = expr

definition :- procname popen {0,formal  } pclose copen process cclose declend

formal :- primitive.type name

instance :- name popen {0, element} pclose

monadic.operator :- neg | not




Grammar Clean

Lexical
    ("WS",      r"[ \t\n]+"),
    ("STOP",    r"STOP"),
    ("SKIP",    r"SKIP"),
    ("IF",      r"IF"),
    ("SEQ",     r"SEQ"),
    ("WHILE", r"WHILE"),
    ("PAR",     r"PAR"),
    ("INT",     r"INT"),
    ("CHAN",    r"CHAN"),
    ("PROC",    r"PROC"),
    ("NOT",     r"NOT"),
    ("LE",      r"<="),
    ("GE",      r">="),
    ("NEQ",     r"<>"),
    ("EQ",      r":="),
    ("LT",      r"<"),
    ("GT",      r">"),
    ("EQQ",     r"="),
    ("DECLEND", r":"),
    ("PLUS",    r"\+"),
    ("MINUS",   r"-"),
    ("MUL",     r"\*"),
    ("FS",      r"/"),
    ("BS",      r"\\"),
    ("AND",     r"&"),
    ("OR",      r"\|"),
    ("CHANIN",  r"\?"),
    ("CHANOUT", r"!"),
    ("COPEN",   r"\{"),
    ("CCLOSE",  r"\}"),
    ("SQOPEN",  r"\["),
    ("SQCLOSE", r"\]"),
    ("POPEN",   r"\("),
    ("PCLOSE",  r"\)"),
    ("NAME",    r"[a-zA-Z_][a-zA-Z0-9_]*"),
    ("INTEGER", r"[0-9]*")

BNF
process :- STOP 
         | SKIP 
         | action 
         | construction
         | instance
         | specification process

action :- assignment 
        | input 
        | output 

assignment :- variable EQ expr (trivial conv c)

input :- channel CHANIN variable 

output :- channel CHANOUT expr 

construction :- seq | cond | loop | par | alt

seq :- SEQ COPEN { process } CCLOSE

cond :- IF COPEN choice CCLOSE

choice :- bool COPEN process CCLOSE

bool :- expr (trivial conv c)

loop :- WHILE bool COPEN process CCLOSE 

par :- PAR COPEN { process } CCLOSE

alt :- guard COPEN process CCLOSE

guard :- input
        | bool AND input

type :- primitive_type
      | SQOPEN literal SQCLOSE primitive_type (trivial conv c)

primitive_type :- INT
                | CHAN

literal :- integer      # Define a token INTEGER as needed

element :- NAME
          | NAME SQOPEN expr SQCLOSE (trivial conv c)

variable :- element

channel :- element

operand :- element
          | literal
          | POPEN expr PCLOSE

expr :- monadic_operator operand (trivial conv c)
       | operand dyadic_operator operand (trivial conv c)
       | operand (trivial conv c)

specification :- declaration
                | definition

declaration :- type NAME DECLEND
              | INT NAME EQQ expr

definition :- NAME POPEN { formal } PCLOSE COPEN process CCLOSE DECLEND

formal :- primitive_type NAME

instance :- NAME POPEN { element } PCLOSE

monadic_operator :- MINUS
                  | NOT

dyadic_operator :- PLUS
                 | MINUS
                 | MUL
                 | FS
                 | BS
                 | EQ
                 | EQQ
                 | LT
                 | LE
                 | GT
                 | GE
                 | NEQ
                 | AND
                 | OR
